generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  User              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Booking {
  id                            String        @id
  startDate                     DateTime
  endDate                       DateTime
  status                        BookingStatus @default(PENDING)
  createdAt                     DateTime      @default(now())
  updatedAt                     DateTime
  itemId                        String
  borrowerId                    String
  ownerId                       String
  totalPrice                    Float         @default(0)
  User_Booking_borrowerIdToUser User          @relation("Booking_borrowerIdToUser", fields: [borrowerId], references: [id])
  Item                          Item          @relation(fields: [itemId], references: [id])
  User_Booking_ownerIdToUser    User          @relation("Booking_ownerIdToUser", fields: [ownerId], references: [id])
  Review                        Review?

  @@index([borrowerId])
  @@index([createdAt(sort: Desc)])
  @@index([itemId])
  @@index([ownerId])
  @@index([status])
}

model Category {
  id          String        @id
  nombre      String        @unique
  descripcion String?
  imagen      String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime
  Subcategory Subcategory[]
}

model Item {
  id          String    @id
  title       String
  description String
  category    String
  location    String
  features    String[]
  images      String[]
  isAvailable Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime
  ownerId     String
  subcategory String?
  deposit     Float     @default(0)
  price       Float
  priceType   String    @default("day")
  latitude    Float?
  longitude   Float?
  Booking     Booking[]
  User        User      @relation(fields: [ownerId], references: [id])
  Review      Review[]

  @@index([category])
  @@index([createdAt(sort: Desc)])
  @@index([isAvailable])
  @@index([ownerId])
}

model Message {
  id                            String   @id
  content                       String
  isRead                        Boolean  @default(false)
  createdAt                     DateTime @default(now())
  senderId                      String
  receiverId                    String
  bookingId                     String?
  User_Message_receiverIdToUser User     @relation("Message_receiverIdToUser", fields: [receiverId], references: [id])
  User_Message_senderIdToUser   User     @relation("Message_senderIdToUser", fields: [senderId], references: [id])
}

model Notification {
  id        String           @id
  type      NotificationType
  content   String
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
  userId    String
  actionUrl String?
  bookingId String?
  itemId    String?
  metadata  Json?
  title     String
  User      User             @relation(fields: [userId], references: [id])

  @@index([createdAt(sort: Desc)])
  @@index([isRead])
  @@index([userId])
}

model Review {
  id                           String    @id
  rating                       Int
  comment                      String
  createdAt                    DateTime  @default(now())
  itemId                       String
  reviewerId                   String
  revieweeId                   String
  bookingId                    String    @unique
  response                     String?
  responseDate                 DateTime?
  Booking                      Booking   @relation(fields: [bookingId], references: [id])
  Item                         Item      @relation(fields: [itemId], references: [id])
  User_Review_revieweeIdToUser User      @relation("Review_revieweeIdToUser", fields: [revieweeId], references: [id])
  User_Review_reviewerIdToUser User      @relation("Review_reviewerIdToUser", fields: [reviewerId], references: [id])

  @@index([createdAt(sort: Desc)])
  @@index([itemId])
  @@index([revieweeId])
}

model Service {
  id             String           @id
  title          String
  description    String
  pricePerHour   Float?
  priceType      String           @default("hour")
  isProfessional Boolean          @default(false)
  category       String
  subcategory    String?
  location       String
  latitude       Float?
  longitude      Float?
  serviceArea    String?
  features       String[]
  images         String[]
  isAvailable    Boolean          @default(true)
  createdAt      DateTime         @default(now())
  updatedAt      DateTime
  providerId     String
  User           User             @relation(fields: [providerId], references: [id])
  ServiceBooking ServiceBooking[]
  ServiceReview  ServiceReview[]

  @@index([category])
  @@index([createdAt(sort: Desc)])
  @@index([isAvailable])
  @@index([providerId])
}

model ServiceBooking {
  id                                   String         @id
  startDate                            DateTime
  endDate                              DateTime?
  hours                                Float?
  customPrice                          Float?
  status                               BookingStatus  @default(PENDING)
  createdAt                            DateTime       @default(now())
  updatedAt                            DateTime
  serviceId                            String
  clientId                             String
  providerId                           String
  User_ServiceBooking_clientIdToUser   User           @relation("ServiceBooking_clientIdToUser", fields: [clientId], references: [id])
  User_ServiceBooking_providerIdToUser User           @relation("ServiceBooking_providerIdToUser", fields: [providerId], references: [id])
  Service                              Service        @relation(fields: [serviceId], references: [id])
  ServiceReview                        ServiceReview?

  @@index([clientId])
  @@index([createdAt(sort: Desc)])
  @@index([providerId])
  @@index([serviceId])
  @@index([status])
}

model ServiceReview {
  id                                  String         @id
  rating                              Int
  comment                             String
  response                            String?
  responseDate                        DateTime?
  createdAt                           DateTime       @default(now())
  serviceId                           String
  reviewerId                          String
  revieweeId                          String
  bookingId                           String         @unique
  ServiceBooking                      ServiceBooking @relation(fields: [bookingId], references: [id])
  User_ServiceReview_revieweeIdToUser User           @relation("ServiceReview_revieweeIdToUser", fields: [revieweeId], references: [id])
  User_ServiceReview_reviewerIdToUser User           @relation("ServiceReview_reviewerIdToUser", fields: [reviewerId], references: [id])
  Service                             Service        @relation(fields: [serviceId], references: [id])
}

model Session {
  id           String   @id
  sessionToken String   @unique
  userId       String
  expires      DateTime
  User         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Subcategory {
  id          String   @id
  nombre      String
  descripcion String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime
  categoryId  String
  Category    Category @relation(fields: [categoryId], references: [id])
}

model User {
  id                                             String           @id
  email                                          String           @unique
  password                                       String?
  firstName                                      String?
  lastName                                       String?
  profileImage                                   String?
  bio                                            String?
  phoneNumber                                    String?
  createdAt                                      DateTime         @default(now())
  updatedAt                                      DateTime
  isVerified                                     Boolean          @default(false)
  verificationToken                              String?
  resetToken                                     String?
  resetTokenExpiry                               DateTime?
  stripeAccountId                                String?          @unique
  stripeCustomerId                               String?          @unique
  stripeOnboarded                                Boolean          @default(false)
  mercadopagoAccessToken                         String?          @unique
  mercadopagoConnected                           Boolean          @default(false)
  mercadopagoConnectedAt                         DateTime?
  mercadopagoRefreshToken                        String?
  mercadopagoUserId                              String?
  verifiedIdentity                               Boolean          @default(false)
  emailVerified                                  DateTime?
  image                                          String?
  name                                           String?
  Account                                        Account[]
  Booking_Booking_borrowerIdToUser               Booking[]        @relation("Booking_borrowerIdToUser")
  Booking_Booking_ownerIdToUser                  Booking[]        @relation("Booking_ownerIdToUser")
  Item                                           Item[]
  Message_Message_receiverIdToUser               Message[]        @relation("Message_receiverIdToUser")
  Message_Message_senderIdToUser                 Message[]        @relation("Message_senderIdToUser")
  Notification                                   Notification[]
  Review_Review_revieweeIdToUser                 Review[]         @relation("Review_revieweeIdToUser")
  Review_Review_reviewerIdToUser                 Review[]         @relation("Review_reviewerIdToUser")
  Service                                        Service[]
  ServiceBooking_ServiceBooking_clientIdToUser   ServiceBooking[] @relation("ServiceBooking_clientIdToUser")
  ServiceBooking_ServiceBooking_providerIdToUser ServiceBooking[] @relation("ServiceBooking_providerIdToUser")
  ServiceReview_ServiceReview_revieweeIdToUser   ServiceReview[]  @relation("ServiceReview_revieweeIdToUser")
  ServiceReview_ServiceReview_reviewerIdToUser   ServiceReview[]  @relation("ServiceReview_reviewerIdToUser")
  Session                                        Session[]
  Verification                                   Verification[]
}

model Verification {
  id               String             @id
  userId           String
  type             VerificationType
  status           VerificationStatus @default(PENDING)
  documentType     String?
  documentNumber   String?
  firstName        String?
  lastName         String?
  birthDate        String?
  gender           String?
  expirationDate   String?
  selfieUrl        String?
  documentFrontUrl String?
  documentBackUrl  String?
  pdf417Data       String?
  faceMatchScore   Float?
  livenessScore    Float?
  verifiedAt       DateTime?
  rejectedAt       DateTime?
  rejectionReason  String?
  metadata         Json?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime
  User             User               @relation(fields: [userId], references: [id])

  @@index([status])
  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum NotificationType {
  BOOKING_REQUEST
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  PAYMENT_RECEIVED
  REVIEW_RECEIVED
  MESSAGE_RECEIVED
  BOOKING_COMPLETED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  REFUNDED
  FAILED
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum VerificationType {
  IDENTITY
  DNI
  EMAIL
  PHONE
}
